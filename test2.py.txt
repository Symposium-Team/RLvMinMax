import chess
import random

# Minimax player
def minimax_player(board):
    # Base case: check if the game is over or reached a maximum depth
    if board.is_game_over() or board.is_checkmate() or board.is_stalemate() or board.is_insufficient_material():
        return None

    best_move = None
    best_score = float('-inf')

    # Generate all legal moves
    legal_moves = list(board.legal_moves)

    for move in legal_moves:
        board.push(move)
        score = minimax(board, 3, False)  # Depth-limited minimax search
        board.pop()

        if score > best_score:
            best_score = score
            best_move = move

    return best_move

def minimax(board, depth, is_maximizing):
    # Base case: reached maximum depth or game over
    if depth == 0 or board.is_game_over() or board.is_checkmate() or board.is_stalemate() or board.is_insufficient_material():
        return evaluate(board)

    if is_maximizing:
        max_score = float('-inf')

        # Generate all legal moves
        legal_moves = list(board.legal_moves)

        for move in legal_moves:
            board.push(move)
            score = minimax(board, depth - 1, False)
            board.pop()
            max_score = max(max_score, score)

        return max_score
    else:
        min_score = float('inf')

        # Generate all legal moves
        legal_moves = list(board.legal_moves)

        for move in legal_moves:
            board.push(move)
            score = minimax(board, depth - 1, True)
            board.pop()
            min_score = min(min_score, score)

        return min_score

def evaluate(board):
    # Simple evaluation function that counts the material advantage for white
    piece_values = {
        chess.PAWN: 1,
        chess.KNIGHT: 3,
        chess.BISHOP: 3,
        chess.ROOK: 5,
        chess.QUEEN: 9,
        chess.KING: 0
    }

    score = 0

    for square in chess.SQUARES:
        piece = board.piece_at(square)

        if piece is not None:
            value = piece_values[piece.piece_type]

            if piece.color == chess.WHITE:
                score += value
            else:
                score -= value

    return score

# Q-learning player
class QLearningPlayer:
    def __init__(self):
        self.q_table = {}

    def get_q_value(self, state, action):
        if state not in self.q_table:
            self.q_table[state] = {}
        if action not in self.q_table[state]:
            self.q_table[state][action] = 0.0
        return self.q_table[state][action]

    def update_q_value(self, state, action, new_q_value):
        if state not in self.q_table:
            self.q_table[state] = {}
        self.q_table[state][action] = new_q_value

    def choose_action(self, board):
        legal_moves = list(board.legal_moves)
        if random.random() < 0.1:
            # Explore: choose a random move
            return random.choice(legal_moves)
        else:
            # Exploit: choose the move with the highest Q-value
            max_q_value = float('-inf')
            best_moves = []
            for move in legal_moves:
                q_value = self.get_q_value(board.fen(), move.uci())
                if q_value > max_q_value:
                    max_q_value = q_value
                    best_moves = [move]
                elif q_value == max_q_value:
                    best_moves.append(move)
            return random.choice(best_moves)

#play game
def play_game():
    board = chess.Board()
    episode = 1

    minimax_player_func = minimax_player  # Fix the variable name here
    qlearning_player = QLearningPlayer()

    while not board.is_game_over():
        if episode <= 20:
            # Minimax player goes first
            if board.turn == chess.WHITE:
                move = minimax_player_func(board)  # Use the correct variable name here
            else:
                move = qlearning_player.choose_action(board)
        else:
            # After 20 episodes, Q-learning player goes first
            if board.turn == chess.WHITE:
                move = qlearning_player.choose_action(board)
            else:
                move = minimax_player_func(board)  # Use the correct variable name here

        board.push(move)

    # Determine the winner
    result = board.result()
    if result == "1-0":
        winner = "Minimax"
    elif result == "0-1":
        winner = "Q-learning"
    else:
        winner = "Draw"

    print("Episode {}: {}".format(episode, winner))

    episode += 1

